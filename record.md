## 杂项
- svn账：putianyang 密：^@bB2Fxf
- Consolas, 'Courier New', monospace

## mysql相关
- update涉及到两次日志记录，一次是server层的binlog，另一次是引擎层的redo-log；其中redo-log的记录涉及到两阶段提交：prepare和commit，主要为了避免和binlog的不一致
- innodb事务的可重复读涉及undo-log的回滚操作，尽量避免开启长事务
- hash索引适用于等值查询，范围查询因为无序涉及全表遍历
- 主键长度越小越好，因为二级索引会更小；只有一个索引的表可以设为主键，其余一般为自增主键
- mysql5.6以后不符合最左匹配原则的部分会采用索引下推优化减少回表次数

### 索引
- 创建索引时的注意点：
  1. 非空字段：应该指定列为NOTNULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值
  2. 取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高
  3. 索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高
- 常见的索引失效情况
  1. 常见的索引失效情况包括以下几种：
  2. 使用函数或表达式：当查询条件中使用函数或表达式时，会导致索引失效。因为MySQL无法对索引中的数据进行函数或表达式计算，必须对所有数据进行计算才能得到查询结果。
  3. 对索引字段进行运算：当查询条件中对索引字段进行运算时，会导致索引失效。因为MySQL无法对索引中的数据进行运算，必须对所有数据进行运算才能得到查询结果。
  4. 使用OR条件：当查询条件中使用OR条件时，会导致索引失效。因为MySQL无法同时使用多个索引，必须对所有数据进行扫描才能得到查询结果。
  5. 字段类型不匹配：当查询条件中使用的字段类型与索引字段类型不匹配时，会导致索引失效。例如，将字符类型的字段与数字类型的索引进行比较，会导致索引失效。
  6. 数据分布不均匀：当数据分布不均匀时，会导致索引失效。因为MySQL可能需要扫描大量的数据块才能得到符合查询条件的数据。
  7. 大数据量的查询：当查询的数据量非常大时，会导致索引失效。因为MySQL可能需要扫描大量的数据块才能得到符合查询条件的数据。

### 锁
InnoDB的行锁是通过在每行数据的索引上设置锁来实现的。具体来说，当一个事务需要锁定某一行数据时，InnoDB会在该行对应的索引上设置一个共享锁（S锁）或排他锁（X锁）。当一个事务需要获取共享锁时，其他事务也可以在该行上获取共享锁，但不能获取排他锁。而当一个事务需要获取排他锁时，其他事务无法在该行上获取任何类型的锁，直到该事务释放该行的锁

### 查询

#### varchar和char
使用CHAR而不是VARCHAR来存储固定长度的字符串，可以提高检索效率的原因是：

1. 存储空间更小：CHAR类型的列在存储时会固定分配一定长度的空间，而VARCHAR类型的列则会根据实际数据长度动态分配空间。因此，使用CHAR类型可以避免存储空间的动态分配，从而减少存储空间的使用，提高存储效率。

2. 检索速度更快：由于CHAR类型的列在存储时已经分配了固定长度的空间，因此在进行检索时可以直接进行定长的比较操作，不需要进行长度判断和计算。而VARCHAR类型的列则需要在进行检索时进行长度判断和计算，这可能会导致检索效率降低。

需要注意的是，使用CHAR类型存储字符串并不是适用于所有情况的。如果存储的字符串长度不固定，或者字符串长度较长，使用VARCHAR类型可能会更加适合。在实际应用中，应根据实际情况选择合适的数据类型，以兼顾存储空间和检索效率的要求。

#### 子查询
在MySQL中，IN和EXISTS都是用于子查询的关键字，它们的作用是判断子查询返回的结果集是否包含指定的值或符合指定的条件。虽然它们的作用类似，但是它们之间还是有一些区别。

IN用于比较值，而EXISTS用于比较条件。

IN关键字用于比较值，判断一个值是否在指定的集合中。例如：

```
SELECT * FROM table WHERE id IN (1, 2, 3);
```

这个查询语句会返回id为1、2或3的所有行。

而EXISTS关键字用于比较条件，判断是否存在符合条件的行。例如：

```
SELECT * FROM table1 WHERE EXISTS (SELECT * FROM table2 WHERE table1.id = table2.id);
```

这个查询语句会返回table1表中与table2表中id相同的所有行。

1. IN适用于固定值，而EXISTS适用于动态条件。IN适用于固定的值列表，例如上面的例子中，我们指定了一个固定的id值列表，用于查询指定的行。而EXISTS适用于动态条件，例如上面的例子中，我们使用了一个子查询来动态地生成条件，查询table1表中存在于table2表中的id的所有行。
2. EXIST性能优于IN。在查询大量数据时，使用EXISTS的性能通常优于IN，因为EXISTS在找到符合条件的第一行时就可以停止查询，而IN则需要扫描整个集合。

总的来说，IN和EXISTS都有自己的使用场景，需要根据具体的需求来选择使用哪个。如果需要查询指定的固定值，可以使用IN；如果需要动态生成条件，可以使用EXISTS。同时，在查询大量数据时，使用EXISTS可能更加高效。

## redis相关
- 分布式锁
```
# 原子性的设置超时
set lock:xx true ex 5
process....
del lock:xx
# 一般不用于执行长时间的任务，以免超过超时时间
# 使用带tag的加锁释放锁，释放锁时需要使用lua保证原子性
```

## 引擎相关
- LogicCLassModule加载logical_class.xml构建逻辑对象
- 玩家进入场景时序
![](/pic/player_1.jpg)


## AI模块
- bevTreeId关联NPC对象和对应一套行为树json文件，AIModule加载时读取对应所有的json文件并转换为各个节点
- AI转换目标的类型
![](/pic/ai_target_type.jpg)


```c++
1. npc--->onEntry()--->检查场景是否开启AI--->createNpcAI()
```

## 战斗和副本相关
- 造成伤害的方式：最终都调用`DoDamage`方法
    + 直接伤害(DamageTarget) 
    + 按攻击公式计算后造成伤害(DamageTargetWithAttack) 
    + 分担伤害(ShareDamage)
```c++
// 伤害事件
FightModule::DoDamage()=>FightModule::NoticeDamage()=>CloneSceneModule::OnCommandDamageTarget()
//
```
## C++
- __thread只支持POD对象，且只能静态初始化；pthread_key_t可以存储复杂对象

## 多线程相关
- 如果需要用到多个锁，保证按照同一顺序添加以免死锁；如果需要锁住相同类型的多个对象，为了保证始终按照同一顺序加锁，可以比较mutex地址
- 作为成员的mutex不能保护析构函数，构造函数中不应该传出this指针
- 线程安全的observer模式：使用智能指针`shared_ptr`和`weak_ptr`而不是加锁；`weak_ptr`的提升操作是线程安全的；但`shared_ptr`只是保证了引用计数的线程安全而不会保证智能指针本身读写的安全，只能由多个线程读，但不能多个线程同时读写
- 单线程eventloop有一个明显的缺点，对优先级不敏感，优先级高的连接不能得到及时处理；对于这种情况可以采用多线程eventloop来避免
- 多线程对于IO或者计算很容易到达瓶颈的场景无能为力，在这两种情形下，选择单线程
- 防止死锁

![](/pic/prevent_dead_lock.png)

## 设计模式
- 组合、关联和聚合: 组合表示部分与整体，部分的生命周期归整体管理；关联表示一种使用，形式上看A持有B的指针或者引用；聚合也是部分与整体，不过部分的生命周期不由整体控制

## 日志模块
- AsyncLogging类是异步日志系统的核心，它负责将日志信息写入磁盘文件。AsyncLogging类的构造函数中，接收三个参数：basename表示日志文件的基础名称，rollSize表示日志文件达到一定大小时需要切换到新的日志文件，flushInterval表示日志信息的刷新间隔。在构造函数中，会初始化一些成员变量，包括flushInterval_、running_、basename_、rollSize_、thread_、latch_、currentBuffer_、nextBuffer_和buffers_。其中，buffers_是一个BufferVector类型的容器，用于存储待写入磁盘文件的缓冲区。
- AsyncLogging类中的append函数用于向异步日志系统中添加日志信息。每次添加日志信息时，会先判断当前缓冲区是否有足够的空间存储该日志信息，如果有，则直接将日志信息添加到当前缓冲区中；否则，将当前缓冲区存储到buffers_容器中，并将nextBuffer_指向当前缓冲区，然后创建一个新的缓冲区currentBuffer_，将日志信息添加到该缓冲区中，最后唤醒异步日志系统的线程。
- AsyncLogging类中的threadFunc函数是异步日志系统的线程函数。在该函数中，会先初始化一些成员变量，包括newBuffer1、newBuffer2和buffersToWrite。newBuffer1和newBuffer2分别表示两个缓冲区，用于轮流存储日志信息；buffersToWrite是一个BufferVector类型的容器，用于存储待写入磁盘文件的缓冲区。
- 在threadFunc函数的主循环中，会先判断buffers_容器是否为空，如果为空，则等待一段时间后再次检查；否则，将当前缓冲区currentBuffer_存储到buffers_容器中，并将newBuffer1指向当前缓冲区，同时将buffers_容器中的缓冲区存储到buffersToWrite容器中，并将nextBuffer_指向newBuffer2。接着，遍历buffersToWrite容器中的缓冲区，将缓冲区中的日志信息写入磁盘文件中，如果缓冲区的数量超过了25个，则只保留前两个缓冲区，并输出一条日志信息表示有日志信息被丢弃。最后，将newBuffer1和newBuffer2指向buffersToWrite容器中的两个缓冲区，清空buffersToWrite容器，并将磁盘文件刷新到磁盘中。
- LogFile负责滚动日志文件，滚动时机包括当前文件已写入的字节数以及append调用次数。每次append会检测当前调用次数累计是否达到设置的阈值，并且如果达到下个时间区域（将time函数的返回分割成均等的时间区域）就会滚动文件；如果还未达到下一个时间区域，则flush一次。

## GDB

### 查看内存
在 GDB 中，可以使用 x 命令（也可以使用 print 命令）来查看内存中的值。x 命令的语法如下：
`x/<n/f/u> <addr>`
其中，格式 和 长度 是可选的参数，用于指定要显示的值的格式和长度。地址 是要查看的内存地址。

下面是一些常用的 格式 和 长度 参数：

- b: 以字节为单位显示值，长度为 1 字节。
- h: 以半字（16 位）为单位显示值，长度为 2 字节。
- w: 以字（32 位）为单位显示值，长度为 4 字节。
- g: 以双字（64 位）为单位显示值，长度为 8 字节。
- s: 以字符串形式显示值。
- u: 以无符号十进制形式显示值。
- x: 以十六进制形式显示值。

例如
- 要查看地址 0x1000 处的 4 个字节的十六进制值，可以输入以下命令：
`x/4x 0x1000`

- 要查看地址 0x2000 处的 8 个字节的无符号十进制值，可以输入以下命令：
`x/8u 0x2000`

- 要查看地址 0x3000 处的字符串值，可以输入以下命令：
`x/s 0x3000`

需要注意的是，x 命令只是用来查看内存中的值，并不能修改内存中的内容。如果需要修改内存中的值，可以使用 set 命令或者其他适当的命令进行修改。

打印数组的内容 `p *array@len`

通过指针打印对象 `p *(<class> *)<address>`

单字节打印10个字节的内存地址 `x/10xb <address>`

### 断点
在 GDB 中，可以使用条件断点来在满足特定条件时触发断点。条件断点可以帮助我们更加精确地调试程序，只在需要的情况下暂停程序的执行。要添加条件断点，可以使用 break 命令，并在命令后面加上 if 子句来指定条件。例如，要在变量 x 的值等于 10 时触发断点，可以使用以下命令：
`break filename:line if x==10`；其中，filename:line 是要设置断点的文件名和行号。x==10 是条件子句，表示只有当变量 x 的值等于 10 时才触发断点。

如果要在当前执行位置添加条件断点，可以使用 break 命令，并指定当前行号作为断点位置。例如，要在当前行添加条件断点，可以使用以下命令：`break if expression`；其中，expression 是要设置的条件表达式。

要列出已经设置的条件断点，可以使用 `info breakpoints` 命令。

如果要删除已经设置的条件断点，可以使用 `delete breakpoints` 命令，并指定要删除的断点编号。

需要注意的是，条件表达式必须是一个合法的 C 语言表达式，并且必须用括号将条件表达式括起来。此外，条件表达式不能包含任何副作用，否则可能会导致程序的行为不可预测。

### 多线程调试
在 GDB 中进行多线程调试时，主要需要使用以下命令：

1. `set scheduler-locking on/off`: 开启或关闭 GDB 的调度器锁定。开启调度器锁定后，GDB 会阻止其他线程在当前线程被暂停时运行。关闭调度器锁定后，所有线程都可以并发运行。

2. `info threads`: 显示当前所有线程的信息，包括线程 ID、状态、当前位置等。

3. `thread <thread-id>`: 切换到指定的线程，其中 `<thread-id>` 是要切换到的线程 ID。

4. `thread apply <thread-group> <command>`: 对指定的线程组应用命令。例如，`thread apply all bt` 命令可以在所有线程上执行 `bt` 命令打印调用栈信息。

5. `break <location> thread <thread-id>`: 在指定的线程上设置断点。例如，`break main thread 2` 命令可以在第二个线程上设置在 `main` 函数处的断点。

6. `info break`: 显示所有断点的信息，包括断点编号、位置、是否启用等。

7. `next`, `step`, `continue` 等命令：这些命令在多线程环境下同样适用，可以用来单步执行、跳过、继续执行等操作。

使用以上命令可以实现在 GDB 中对多线程程序进行调试。需要注意的是，多线程调试比单线程调试更加复杂，需要仔细考虑各个线程之间的交互和状态同步问题，以避免出现死锁等问题。


## Rust

vscode的settings.json
```
{
    "editor.semanticTokenColorCustomizations": {
        "enabled": true,
        "rules": {
            "*.mutable": {
                "underline": false,
            }
        }
    },

    "editor.inlayHints.enabled": "off"
}
```